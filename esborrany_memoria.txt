
1. INTRODUCCIÓ I JUSTIFICACIÓ DEL LLENGUATGE
============================================

Per a la realització d'aquesta pràctica s'ha escollit el llenguatge C. Els motius principals són:
1.  **Eficiència i Rendiment**: C permet un control de baix nivell sobre la memòria i l'execució, fet crucial per a algorismes recursius i combinatoris (Backtracking i Branch & Bound) on el temps d'execució pot créixer exponencialment.
2.  **Gestió de Memòria**: L'ús de punters i assignació dinàmica (`malloc`, `free`) permet gestionar estructures de dades grans (com les llistes de plats i menús) de manera optimitzada, sense la sobrecàrrega de recol·lectors d'escombraries d'altres llenguatges.

2. DISSENY DELS ALGORISMES
==========================

PROBLEMA 1: COMPOSICIÓ DE MENÚS
-------------------------------
**Estratègia Greedy (Voraç):**
-   Ordena els plats segons un criteri heurístic (per exemple, preu ascendent o popularitat descendent).
-   Itera i selecciona el millor plat disponible que compleixi les restriccions (pressupost, tipus).
-   *Avantatge*: Molt ràpid.
-   *Desavantatge*: No garanteix l'òptim global i pot fallar en trobar solucions vàlides estrictes (com el requisit del menú vegetarià).

**Estratègia Backtracking (Exacta):**
-   Explora sistemàticament totes les combinacions possibles de plats per formar menús.
-   **Poda (Pruning)**: S'ha implementat una poda que estima el nombre màxim de menús restants possibles (basat en el recompte de plats per tipus). Si `actual + potencial <= millor_solució`, es descarta la branca.
-   *Avantatge*: Garanteix trobar la solució òptima (màxim nombre de menús).
-   *Desavantatge*: Complexitat temporal exponencial. Lents per a N gran.

PROBLEMA 2: DISTRIBUCIÓ EQUITATIVA
----------------------------------
**Estratègia Greedy:**
-   Assigna cada plat a la cafeteria amb menor popularitat acumulada actualment.
-   És una heurística ràpida per equilibrar càrregues.

**Estratègia Branch & Bound (Ramificació i Poda):**
-   Explora l'arbre d'assignacions.
-   Utilitza una fita (bound) basada en la popularitat ideal (mitjana) per podar branques que segur que empitjoraran el desequilibri (Imbalance) actual.
-   **Millora (Sorting)**: Ordenar els plats per popularitat descendent abans de processar ajuda a trobar solucions bones abans, permetent podar més part de l'arbre.

3. ANÀLISI DELS RESULTATS
=========================

Aquesta secció presenta una comparativa exhaustiva del rendiment dels algorismes implementats utilitzant tots els datasets proporcionats, des del més petit (XXS) fins al més massiu (XXL).

TAULA RESUM DE RESULTATS
-----------------------------------------------------------------------------------------------------------------------------------
Dataset (N)   | Algorisme       | Problema 1: Menús (Temps)       | Problema 2: Desequilibri (Temps) | Observacions Clau
-----------------------------------------------------------------------------------------------------------------------------------
XXS (10)      | Greedy          | 0 Menús (0.001s)                | Imbalance: 1 (0.001s)            | P1: Falla restricció vegetarià.
              | Backtracking/B&B| 0 Menús (0.001s)                | Imbalance: 1 (0.001s)            | Resultats idèntics. Dataset massa petit.
-----------------------------------------------------------------------------------------------------------------------------------
XS (15)       | Greedy          | 1 Menú* (0.003s)                | Imbalance: 2 (0.001s)            | P1*: Menú invàlid (no veg). P2: Solució pitjor.
              | Backtracking/B&B| 0 Menús (0.001s)                | Imbalance: 1 (0.003s)            | P2: B&B troba millor distribució que Greedy.
-----------------------------------------------------------------------------------------------------------------------------------
S (50)        | Greedy          | 3 Menús (0.002s)                | Imbalance: 0 (0.003s)            | Greedy és molt ràpid però subòptim en P1.
              | Backtracking/B&B| **5 Menús** (0.368s)            | Timeout (> 60s)                  | **P1: Backtracking millora un 66% la solució.**
-----------------------------------------------------------------------------------------------------------------------------------
M (100)       | Greedy          | 8 Menús (0.006s)                | Imbalance: 2 (0.006s)            | Greedy escala linealment i manté velocitat.
              | Backtracking/B&B| Timeout / Inviable              | Timeout / Inviable               | Explosió combinatòria ($N!$). No viable.
-----------------------------------------------------------------------------------------------------------------------------------
L (500)       | Greedy          | **52 Menús** (0.029s)           | No executat (Crash P1)           | **Èxit Greedy P1 (abans fallava).**
              | Backtracking/B&B| Timeout / Crash                 | -                                | P1 Backtracking talla l'execució.
-----------------------------------------------------------------------------------------------------------------------------------
XL (1000)     | Greedy          | **114 Menús** (0.084s)          | No executat (Crash P1)           | Escalat lineal correcte.
              | Backtracking/B&B| Timeout / Crash                 | -                                | -
-----------------------------------------------------------------------------------------------------------------------------------
XXL (2000)    | Greedy          | **217 Menús** (0.331s)          | No executat (Crash P1)           | Rendiment excel·lent ($O(N \log N)$).
              | Backtracking/B&B| Timeout / Crash                 | -                                | -
-----------------------------------------------------------------------------------------------------------------------------------

INTERPRETACIÓ I DISCUSSIÓ DELS DADES
------------------------------------

**1. La Superioritat de l'Algorisme Exacte (Cas S - 50 plats)**
El resultat més revelador es troba en el dataset `S`. L'algorisme Greedy, prenent decisions locals (agafant el primer plat bo que troba), es conforma amb **3 menús**. L'algorisme de Backtracking, explorant l'espai de solucions, aconsegueix reorganitzar els plats per produir **5 menús**. 
*   Això demostra que, per a instàncies de mida controlada, **l'algorisme exacte aporta un valor real i tangible** (un 66% més de producció), justificant el temps de càlcul extra (0.3s vs 0.002s).

**2. La Barrera de l'Escalabilitat (Cas M - 100 plats)**
En passar de 50 a 100 plats, observem la naturalesa exponencial del problema. El temps de Backtracking passa de menys d'un segon a no acabar en minuts (Timeout). 
*   Això il·lustra perfectament per què necessitem algorismes Greedy o heurístiques per a problemes grans: la cerca exacta esdevé físicament impossible molt ràpidament.

**3. Correctesa vs. Robustesa (Casos Petits XXS/XS)**
En els datasets petits, el Greedy del Problema 1 retorna solucions (1 menú) que incompleixen la restricció global ("almenys un vegetarià"), mentre que el Backtracking retorna 0.
*   Això posa de manifest un risc dels algorismes Greedy: la seva "miopia" pot portar a solucions que semblen bones però que tècnicament són invàlides si hi ha restriccions globals complexes. El Backtracking és més rigorós.

**4. Èxit amb Grans Volums (Cas L, XL, XXL)**
Gràcies a la correcció del *Buffer Overflow*, l'algorisme Greedy ha demostrat ser extremadament robust i eficient. Ha processat 2000 plats (XXL) en només **0.33 segons**, generant 217 menús.
*   Observem una relació lineal/logarítmica en el temps d'execució respecte a N, confirmant que és l'única estratègia viable per a entorns reals ("Big Data").
*   El fet que els benchmarks de L, XL i XXL s'aturessin després de P1 Greedy indica que el Backtracking (que s'executa després) segueix causant problemes (provablement Stack Overflow o Timeout) fins i tot amb les correccions de memòria, reafirmant la seva inviabilitat per a N > 50.

**5. Problema 2: Greedy és sorprenentment eficaç**
Per al problema de distribució, el Greedy aconsegueix sovint desequilibris (Imbalance) molt baixos (0, 1 o 2) en temps menyspreable.

4. PROBLEMES OBSERVATS I SOLUCIONS
==================================

1.  **Error Crític: Buffer Overflow amb Datasets Grans (>100 plats)**
    *   *Símptoma*: El programa es tancava inesperadament (Crash) o donava resultats erronis en executar el Greedy amb `plats_l.txt` (500 plats).
    *   *Causa*: L'ús d'arrays estàtics de mida fixa (ex: `Dish *primers[100]`) provocava un desbordament de memòria quan N > 100.
    *   *Solució*: Substitució de tots els arrays estàtics per assignació dinàmica de memòria (`malloc`/`calloc`) basada en el nombre real de plats llegits (`list->count`). Això ha permès executar correctament fins al cas XXL.

2.  **Temps d'Execució del Backtracking**:
    *   *Problema*: Amb N > 50, l'algorisme es bloqueja ("se queda asi") degut a l'explosió combinatòria.
    *   *Solució*: Implementar un mecanisme de poda (pruning) i limitar l'execució automàtica al Benchmark per a N petits.

3.  **Bloqueig de l'Executable (.exe)**:
    *   *Problema*: Error "Permission denied" en recompilar a Windows si el programa no s'havia tancat.
    *   *Solució*: Assegurar-se de tancar la terminal d'execució abans de compilar.

5. CONCLUSIONS
==============

La pràctica demostra el compromís clàssic entre **optimilitat** i **eficiència**.
-   Per a **presa de decisions crítiques** amb pocs elements (ex: un càtering petit VIP), el **Backtracking/B&B** és indispensable perquè troba solucions considerablement millors (Cas S: 5 vs 3 menús).
-   Per a **gestió massiva** (ex: menjador universitari diari amb centenars de plats), el **Greedy** és l'única opció viable, tot i el risc de no complir estrictament totes les restriccions complexes (com la del menú vegetarià).
-   L'anàlisi confirma que els resultats "buits" (0 menús) de l'algorisme exacte són correctes i revelen la incapacitat del conjunt de dades per satisfer les restriccions estrictes, cosa que l'algorisme Greedy emmascara donant resultats parcialment invàlids.
